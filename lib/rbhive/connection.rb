# suppress warnings
old_verbose, $VERBOSE = $VERBOSE, nil
# require thrift autogenerated files
require File.join(File.dirname(__FILE__), *%w[.. thrift thrift_hive])
# restore warnings
$VERBOSE = old_verbose

module RBHive
  def connect(server, port=10_000)
    connection = RBHive::Connection.new(server, port)
    ret = nil
    begin
      connection.open
      ret = yield(connection)
    ensure
      connection.close
      ret
    end
  end
  module_function :connect
  
  class StdOutLogger
    %w(fatal error warn info debug).each do |level| 
      define_method level.to_sym do |message|
        STDOUT.puts(message)
     end
   end
  end

  class Connection
    attr_reader :client
    
    def initialize(server, port=10_000, logger=StdOutLogger.new)
      @transport = Thrift::Socket.new(server,10_000)
      @protocol = Thrift::BinaryProtocol.new(@transport)
      @client = TCLIService::Client.new(@protocol)
      @logger = logger
      @logger.info("Connecting to #{server} on port #{port}")
      @mutex = Mutex.new 
    end
    
    def open
      @transport.open 
      
      #### TCLI specific requirements
      @open_req = TOpenSessionReq.new
      @open_resp = @client.OpenSession(@open_req)
      @sessHandle = @open_resp.sessionHandle
    end
    
    def close
      @close_req = TCloseOperationReq.new(:operationHandle => @stmtHandle)
      @client.CloseOperation(@close_req)

      @closeConnectionReq = TCloseSessionReq.new(:sessionHandle => @sessHandle)
      @client.CloseSession(@closeConnectionReq)
      @transport.close
    end
    
    def client
      @client
    end
    
    def execute(query)
      execute_safe(query)
    end
    
    def explain(query)
      safe do
        execute_unsafe("EXPLAIN "+ query)
        ExplainResult.new(fetchAll)
      end
    end
    
    def priority=(priority)
      set("mapred.job.priority", priority)
    end
    
    def queue=(queue)
      set("mapred.job.queue.name", queue)
    end
    
    def set(name,value)
      @logger.info("Setting #{name}=#{value}")
      execute_safe("SET #{name}=#{value}")
    end
    
    def fetch(query)
      safe do
        execute_unsafe(query)
        rows = fetchAll
        the_schema = SchemaDefinition.new(get_schema, rows.first)
        ResultSet.new(rows, the_schema)
      end
    end
    
    def fetch_in_batch(query, batch_size=1_000)
      safe do
        execute_unsafe(query)
        until (next_batch = fetchAll(batch_size)).empty?
          the_schema ||= SchemaDefinition.new(get_schema, next_batch.first)
          yield ResultSet.new(next_batch, the_schema)
        end
      end
    end
    
    def first(query)
      safe do
        execute_unsafe(query)
        row = fetchOne
        the_schema = SchemaDefinition.new(get_schema, row)
        ResultSet.new([row], the_schema).first
      end
    end
    
    def schema(example_row=[])
      safe { SchemaDefinition.new(get_schema, example_row) }
    end
    
    def create_table(schema)
      execute(schema.create_table_statement)
    end
    
    def drop_table(name)
      name = name.name if name.is_a?(TableSchema)
      execute("DROP TABLE `#{name}`")
    end
    
    def replace_columns(schema)
      execute(schema.replace_columns_statement)
    end
    
    def add_columns(schema)
      execute(schema.add_columns_statement)
    end
    
    def method_missing(meth, *args)
      client.send(meth, *args)
    end
    
    private
    
    def execute_safe(query)
      safe { execute_unsafe(query) }
    end
    
    def execute_unsafe(query)
      @logger.info("Executing Hive Query: #{query}")

      @execReq = TExecuteStatementReq.new :sessionHandle => @sessHandle, :statement => query
      @execResp = @client.ExecuteStatement(@execReq)
      @stmtHandle = @execResp.operationHandle
      
    end

    ### new thrift implementation requres a max row count. I didn't know exactly what to put, so I used the max limit
    def fetchAll(maxrows=(2**31)-1)

      ret = nil 
      if @execResp.operationHandle.hasResultSet
        @fetchReq = TFetchResultsReq.new :operationHandle => @stmtHandle, :orientation => 4, :maxRows => maxrows
        @resultsResp = @client.FetchResults @fetchReq
        @resultsSet = @resultsResp.results
        @resultRows = @resultsSet.rows

        ### there are definitely better ways of doing this, but this seemed like the easiest quick fix - emulates existing rbhive gem
        ret = @resultRows.map(&:colVals).map{ |x| x.map(&:get_value).map(&:value).join(sep="\t")} 
      end

      ret
    end

    def fetchOne
      fetchAll(1)
    end

    def get_schema
      metadataReq = TGetResultSetMetadataReq.new :operationHandle => @stmtHandle
      metadataResp = @client.GetResultSetMetadata metadataReq
      metadataResp.schema
    end
    
    def safe
      ret = nil
      @mutex.synchronize { ret = yield }
      ret
    end
  end
end
